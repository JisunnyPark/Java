자바의 정석 6장

1. 객체
변수 + 메서드의 집합
클래스라는 설계도로 만든 ‘인스턴스’
2. 클래스와 객체
클래스 : 멤버변수 + 메서드로 이루어진 객체생성을 위한 ‘설계도’
객체 : 클래스를 통해 만들어진 실체
ex) 클래스 - Tv설명서 / 객체 - Tv
객체 생성방법 Tv t = new Tv();
3. 변수와 메서드
1) 변수 종류
class 클래스명{
    int iv; // 인스턴스 변수
    static int cv; // 클래스 변수
    // iv+cv = 멤버변수
}

void method(){
    int lv = 0; // 지역변수
}
iv는 인스턴스 생성시 생성된다(개별)
cv는 메서드 내부에서만 사용가능 (초기화 필수)
2) 클래스변수와 인스턴스 변수
cv : 공유속성
iv : 개별속성
class Prac{
    // 카드의 넓이와 높이는 공유속성 -> cv
    static int width;
    static int height;

    // 카드의 종류와 숫자는 개별속성 -> iv
    String kind;
    int num;
}
3) 메서드
재사용성, 중복코드제거
구조 : 선언부 + 구현부
특징
리턴값 없으면 void
반환값 반환타입 일치해야 함
4) JVM 메모리 구조
Method area : 클래스 정보 저장
Call stack : 메서드 실행시 차례로 실행
Heap : 인스턴스 생성시 저장
call stack
쌓인 순서와 반대로 실행
하나의 메서드만 실행
실행 메서드 바로 밑이 호출 메서드
5) 기본형 매개변수와 참조형 매개변수
기본형 (read only)
참조형 (read & write)
6) 재귀 (x)
7) 클래스 메서드와 인스턴스 메서드
im -> iv 사용 o (객체 생성 필요)
cm -> iv 사용 x (객체 생성 불필요)
im은 iv관련 작업할 때 쓰는 메서드
cm은 im이나 iv와 관련 없는 작업할 때 쓰는 메서드
사용시 static 있으면 cm 없으면 im
4. 오버로딩
1) 오버로딩?
같은 이름의 메서드를 여러개 정의한 것
ex) println()
2) 조건
메서드명 일치 ex) println()
매개변수 개수 or 타입 달라야
반환타입 상관 x
5. 생성자
1) 생성자?
인스턴스 초기화 메서드
메서드와 차이점
리턴값 x, void 사용 x
생성자이름 == 클래스이름
모든 클래스 생성자 1개 이상 필수
2) 기본생성자
매개변수 없는 생성자
3) (x)
4) 생성자에서 다른 생성자 호출
this() 사용
조건
클래스이름 대신 this() 사용
반드시 첫줄에 작성
참조변수 this
this는 변수명 구별용
ex) this.color = color; // this.color는 iv, color는 lv
6. 변수의 초기화
1) 변수의 초기화
지역변수는 사용전 초기화 필수
멤버변수 초기화 방법
명시적 초기화 (간단)
생성자 (복잡)
초기화블럭 (복잡)
2) 명시적 초기화 -> 기본초기화 (=)
3) 초기화블럭
클래스 초기화블럭 - static{}
인스턴스 초기화블럭 - {}
4) 초기화 순서
cv -> iv
자동 -> 간단 -> 복잡(초기화블럭 -> 생성자)

자바의 정석 7장

1. 상속
1) 상속이란?
기존의 클래스를 재사용해서 새로운 클래스를 작성
조상과 자손으로 관계맺음
자손은 조상의 모든 멤버 상속받음
사용법
class 자손클래스 extends 조상클래스{}
2) 상속관계
공통부분 조상에서, 개별부분 자손에서 관리
3) 포함관계
한 클래스의 멤버 변수로 다른 클래스 선언
4) 단일상속
Java는 단일상속만을 허용
5) Object 클래스
조상없는 클래스는 object클래스 상속
2. 오버라이딩
1) 오버라이딩이란?
조상메서드를 자손에 맞게 변경(덮어쓰기)
2) 조건
선언부가 같아야 함
접근제어자 좁은 범위로 변경 x (public->private x)
조상보다 많은 수의 예외 x
내부만 변경
3) 오버로딩 vs 오버라이딩
오버로딩
새로운 메서드 정의(new)
상속과 관련 x
오버라이딩
상속받은 메서드의 내용변경(change)
4) super 참조변수
this vs super
this: 인스턴스 자신의 참조변수
super: 조상의 참조변수
super() 조상의 생성자
자손 인스턴스 생성시, 자손+조상 멤버 합친 하나의 인스턴스 생성
자손 생성자의 첫 문장에서 호출(조상 멤버로 초기화 되어야 함)
3. Package와 Import
1) 패키지
서로 관련된 클래스와 인터페이스의 묶음
클래스는 파일, 패키지는 폴더
.으로 구분
2) x
3) 클래스패스 설정 (x)
4) Import
사용할 클래스가 속한 패키지 지정
컴파일시 처리
4. 제어자
1) 제어자란?
클래스, 변수, 메서드 선언부에 사용되어 부가적인 의미 부여
public, protected, (default), private (넓->좁)
2)~6) (x)
7) 접근제어자 (캡슐화) 사용 이유
외부로부터 데이터 보호위해
내부적으로만 사용되는 부분 감추기 위해
5. 다형성
1) 다형성이란?
조상타입의 참조변수로 자손타입의 인스턴스를 다룰 수 있는 것
2) 참조변수의 형변환
상속관계 타입간만 형변환 가능
값은 그대로. 사용할 수 있는 멤버개수만 달라짐
3) instanceof 연산자
형변환 가능 여부 확인
실제 타입 체크
4) (x)
5) 매개변수의 다형성 (다형성의 장점 1)
참조형 매개변수는 메서드 호출시 자신과 같은 타입 or 자손 타입의 인스턴스를 넘겨줄 수 있다
여러개 조상들이 공통으로 사용하는 함수의 매개변수에 조상의 매개변수를 쓰면? -> 자손까지 그 함수 사용가능
6) 여러 종류의 객체를 배열로 다루기 (다형성의 장점 2)
6. 추상클래스
1) 추상클래스란?
미완성 설계도
추상 메서드를 포함하고 있는 클래스
왜? -> 클래스 선언부의 abstract를 보고 이 클래스에는 추상메서드가 있으니 상속을 통해서 구현해주어야 한다는 것을 쉽게 알 수 있기 때문
생성자, 멤버변수, 메서드 모두 가질 수 있다.
abstract class 클래스이름 { ... }

2) 추상메서드란?
선언부만 작성하고 구현부(body)는 작성하지 않은 채로 남겨 둔 것
왜? -> 메서드의 내용을 상속받는 클래스에 따라 다르게 만들고 싶어서
구현부가 없어서 중괄호{}를 넣지 않는다
abstract 리턴타입 메서드이름();

자손클래스에서 오버라이딩해도 되는데 굳이 왜? -> 자손 클래스에서 추상메서드를 반드시 구현하도록 강요하기 위해(빈 메소드인지 알기 어렵다)

7. 인터페이스
1) 인터페이스란?
껍데기 설계도
추상메서드의 집합(예외: default, static method / 상수는 신경쓰지 말자)
2) 인터페이스의 작성
interface 인터페이스이름 { // class 대신 interface
    public static final 타입 상수이름 = 값; // 상수
    public abstract 메서드이름(매개변수); // 추상메서드
}
public static final / public abstract 생략가능
3) 인터페이스의 상속
인터페이스로부터만 상속받을 수 있음
다중상속 가능
4) 인터페이스의 구현(implements)
extends대신 implements
상속과 구현 동시에 사용 가능
class 클래스이름 implements 인터페이스이름 { // 완성할때는 일반 class
    // 추상메서드 구현
}
class Fighter extends Unit implements Fightable {
    // ...
}
5) 인터페이스를 이용한 다중상속(참고만)
6) 인터페이스를 이용한 다형성(중요)
다형성 : 조상타입의 참조변수로 자손클래스의 인스턴스를 참조가능
인터페이스 다형성 : 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조가능
Fightable f = (Fightable) new Fighter();
//또는
Fightable f = new Fighter();

Fightable타입의 참조변수로는 인터페이스 Fightable에 정의된 멤버들만 호출가능
비유) 옛날 리모컨으로 현재 TV조작가능 but 새로운 기능 사용불가 (리모컨에 버튼이 없음)
7) 인터페이스의 장점
개발시간 단축
A팀과 B팀이 동시에 개발가능
인터페이스 작성
A팀은 메서드의 내용 작성
B팀은 메서드를 호출하여 프로그래밍
표준화 가능

Oracle, MySQL등 다양한 데이터베이스 대응 힘듬
Java - JDBC(인터페이스)만을 이용해 DB개발
각 DB회사들이 JDBC인터페이스로 연결되는 부분 개발
클래스에 새로운 공통점 만들어서 연결 가능

SCV(지상), 탱크(지상), 드랍쉽(공중) 유닛간 묶기 어려움
고칠수 있다는 공통특징으로 주어 묶고 싶을 때 사용
 class SCV extends GroundUnit implements Repairable {}
 class Tank extends GroundUnit implements Repairable {}
 class Dropship extends AirUnit implements Repairable {}
독립적인 프로그래밍 가능
선언과 구현을 분리시킬 수 있다
8) 인터페이스의 이해
클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있다.
메서드를 사용하는 쪽에서는 사용하려는 메서드의 선언부만 알면 된다.(내용은 몰라도 된다.)
9) 디폴트 메서드와 static메서드 (JDK 1.8)
실무에서는 JDK 1.5 ~ 1.6을 많이 사용해서 당분간은 사용할 일이 별로 없음

디폴트 메서드
추상 메서드의 기본적인 구현을 제공하는 메서드
static 메서드
Collections클래스에 존재 (11장)
8. 내부 클래스
1) 내부 클래스란?
클래스 내에 선언된 클래스
내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근
코드의 복잡성 줄인다(캡슐화)

참고 : https://jonny-cho.github.io/
